#!/usr/bin/env node

'use strict';

const assert = require('assert');
const os = require('os');
const path = require('path');
const fs = require('bfile');
const paths = require('../../lib/paths');
const cfg = require('../../lib/config');
const util = require('../../lib/util');
const {writeJSON, readJSON} = util;

const SPENDABLES = new Set(['NONE', 'OPEN', 'REDEEM']);

class Bucket {
  constructor(min, max) {
    this.min = min;
    this.max = max;

    this.coins = 0;
    this.value = 0;
  }

  addCoin(coin) {
    this.coins++;
    this.value += coin.value;
  }
}

class CoinDistribution {
  constructor(initial, exponent) {
    assert(exponent > 0);
    this.exponent = exponent;

    this.buckets = [];
    this.currentBucket = null;
    this.currentBucketIdx = 0;

    // ensure coins are sorted.
    this.lastCoinValue = 0;

    this.init(initial);
  }

  init(initial) {
    assert(Array.isArray(initial));
    const initBuckets = initial.slice();

    initBuckets.sort((a, b) => a - b);
    assert(initBuckets[0] >= 0);

    this.exponentStart = initBuckets[initBuckets.length - 1];

    let min = initBuckets[0];
    for (const bucketMax of initBuckets) {
      const bucket = new Bucket(min, bucketMax);
      min = bucketMax;
      this.buckets.push(bucket);
    }

    this.currentBucket = this.buckets[0];
    this.currentBucketIdx = 0;
  }

  addCoin(coin) {
    if (!SPENDABLES.has(coin.covenant.action))
      return;

    // ensure data was sorted.
    assert(coin.value >= this.lastCoinValue);

    if (coin.value > this.currentBucket.max)
      this.createBuckets(coin.value);

    this.currentBucket.addCoin(coin);
    this.lastCoinValue = coin.value;
  }

  createBuckets(value) {
    assert(value > this.currentBucket.max);

    while (value > this.currentBucket.max) {
      if (this.buckets[this.currentBucketIdx + 1]) {
        this.currentBucket = this.buckets[this.currentBucketIdx + 1];
        this.currentBucketIdx++;
        continue;
      }

      const newMin = this.currentBucket.max;
      const newMax = this.currentBucket.max * this.exponent;
      const bucket = new Bucket(newMin, newMax);

      this.currentBucket = bucket;
      this.buckets.push(bucket);
    }
  }

  toJSON() {
    return {
      buckets: this.buckets
    };
  }
}

function help() {
  // eslint-disable-next-line max-len
  const help = `./bin/coinstates/get-coin-distribution WALLET_ID [STEP] [OPTIONS]
  OPTIONS:
    --all - Do every step from STEP to the last.
    --from-chain-dump
    --format  - format numbers.
    --init-buckets - comma separated initial buckets. (e.g. 0,100000)
    --exponent - bucket ranges after last bucket.

  STEPS:
    0, dump: Dump all coins for the wallet.
    1, sum: Summarize information.
    status: Get status.
    all: Do steps from 1. (not 0)
  `;

  console.error(help);
  process.exit(2);
}

(async () => {
  const config = cfg.parse();

  const id = config.str(0);

  if (!id)
    help();

  const fromChainDump = config.bool('from-chain-dump', false);
  const dataRoot = config.str('data-dir', os.tmpdir());
  const dataDir = path.join(dataRoot, `get-coin-distribution-${id}`);
  const format = config.bool('format', false);
  const initBuckets = config.str('init-buckets', '0,1500,100000');
  const exponent = config.int('exponent', 10);

  let fileCoins = paths.coinsDumpFile(dataRoot, id);

  if (fromChainDump)
    fileCoins = paths.chainCoinsDumpFile(dataRoot, id);

  const fileSummed = path.join(dataDir, '1-summary.json');

  await fs.mkdirp(dataDir);

  const step = config.str(1, 'all');

  let fallthrough = config.bool('all', false);

  switch (step) {
    case '0':
    case 'dump': {
      if (fromChainDump) {
        throw new Error(
          // eslint-disable-next-line max-len
          'Please execute ./bin/dump/dump-coins-low before and/or skip step 0/dump.'
        );
      }

      console.log('Getting wallet coins...');
      const env = cfg.configToENV(config);

      await Promise.all([
        util.spawn(paths.execs.dumpBlockTimes, null, { env }),
        util.spawn(paths.execs.dump, ['coins', id], { env })
      ]);

      if (!fallthrough)
        break;
    }

    case 'all':
      fallthrough = true;

    case '1':
    case 'sum': {
      const buckets = initBuckets.split(',').map(v => Number(v));
      const info = new CoinDistribution(buckets, exponent);
      const coins = await readJSON(fileCoins, true);
      const coinsByValue = coins.sort((a, b) => a.value - b.value);

      for (const coin of coinsByValue) {
        info.addCoin(coin);
      }

      await writeJSON(fileSummed, info, false);

      if (!fallthrough)
        break;
    }

    case 'status': {
      let info = await readJSON(fileSummed, false);

      if (format)
        info = formatInfo(info);

      console.log(JSON.stringify(info, null, 2));
    }
  }
})().catch((e) => {
  console.error(e);
  process.exit(1);
});

function formatNumber(number) {
  return number.toLocaleString();
}

function parseNums(obj, formatFn) {
  if (typeof obj === 'number')
    return formatFn(obj);

  assert(typeof obj === 'object', 'obj needs to be an object.');

  const copy = {};
  for (const key of Object.keys(obj))
    copy[key] = parseNums(obj[key], formatFn);

  return copy;
}

function formatInfo(info, locale) {
  const balance = {
    coin: formatNumber(info.balance.coin, locale),
    unconfirmed: util.amount(info.balance.unconfirmed, locale),
    confirmed: util.amount(info.balance.confirmed, locale),
    lockedUnconfirmed: util.amount(info.balance.lockedUnconfirmed, locale),
    lockedConfirmed: util.amount(info.balance.lockedConfirmed, locale)
  };

  const coins = parseNums(info.coins, formatNumber, locale);
  const balances = parseNums(info.balances, util.amount);

  return {
    balance,
    coins,
    balances
  };
}
